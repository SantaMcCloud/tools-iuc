<tool id="obi_illumina_pairend" name="Illuminapairedend" version="@TOOL_VERSION@+galaxy1" profile="@PROFILE@">
    <description>Construct consensus reads from Illumina pair-end reads</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="bio_tools"/>
    <expand macro="requirements"/>
    <expand macro="stdio"/>
    <command>
        <![CDATA[
        #if $inputfastq.forward.ext.endswith(".gz")
            gunzip -c '$inputfastq.forward' > fastq3p.fastq &&
            gunzip -c '$inputfastq.reverse' > fastq5p.fastq &&
        #else
            ln -s '$inputfastq.forward' fastq3p.fastq &&
            ln -s '$inputfastq.reverse' fastq5p.fastq &&
        #end if

        illuminapairedend
        ##--index-file=
        #if $inputfastq.forward.ext.startswith("fastqsolexa")
            ##input file is in fastq nucleic format produced by solexa sequencer
            --solexa
        #else if $inputfastq.forward.ext.startswith("fastqillumina")
            ##input file is in fastq nucleic format produced by solexa sequencer
            --illumina
        #else
            ## input file is in sanger fastq nucleic format (standard fastq)
            --sanger
        #end if
        --without-progress-bar
        --score-min='$score'
        -r fastq3p.fastq
        fastq5p.fastq
        #if $inputfastq.forward.ext.endswith(".gz")
            | gzip -c
        #end if
        > '$output'
        ]]>
    </command>
    <inputs>
        <param name="inputfastq" format="fastqsanger,fastqsanger.gz,fastq,fastq.gz" type="data_collection" collection_type="paired" label="Paired reads" help="file of 3p and 5p Illumina pair-end reads to assemble in sanger fastq nucleic format (standard fastq)"/>
        <param name="score" type="float" value="40.0" label="minimum score for keeping aligment"/>
    </inputs>
    <outputs>
        <data name="output" format_source="inputfastq"/>
    </outputs>

    <tests>
       <test expect_num_outputs="1">
           <param name="inputfastq">
                    <collection type="paired">
                        <element name="forward" value="wolf_small.F.fastq" ftype="fastqsanger"/>
                        <element name="reverse" value="wolf_small.R.fastq" ftype="fastqsanger"/>
                    </collection>
            </param>
           <param name="score" value="40.0" />
           <output name="output" file="illuminapairedend.output.fastq" ftype="fastqsanger" />
       </test>
       <test expect_num_outputs="1">
           <param name="inputfastq">
                    <collection type="paired">
                        <element name="forward" value="wolf_small.F.fastq.gz" ftype="fastqsanger.gz"/>
                        <element name="reverse" value="wolf_small.R.fastq.gz" ftype="fastqsanger.gz"/>
                    </collection>
            </param>
           <param name="score" value="40.0" />
           <output name="output" file="illuminapairedend.output.fastq.gz" ftype="fastqsanger.gz" decompress="true"/>
       </test>
    </tests>

    <help><![CDATA[

.. class:: warning

**Warning:**
Sequence records corresponding to the same read pair must be in the same order in the two files

--------

.. class:: infomark

**What it does**

illuminapairedend aims at aligning the two reads of a pair-end library sequenced using an Illumina platform :

\* If the two reads overlap, it returns the consensus sequence together with its quality
\* Otherwise, it concatenates sequence merging the forward read and the reversed-complemented reverse read.

The program uses as input a pair of fastq sequences read datasets.

illuminapairedend aligns the forward sequence record with the reverse complement of the reverse sequence record. The alignment algorithm takes into account the base qualities.

@OBITOOLS_LINK@

]]>
    </help>
    <expand macro="citation" />

</tool>




