<tool id="fastq_groupmerge" name="Fastq groupmerge" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <macros>
        <token name="@TOOL_VERSION@">1.0.1</token>
        <token name="@VERSION_SUFFIX@">0</token>
        <token name="@PROFILE@">25.0</token>
    </macros>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">fastq-groupmerge</requirement>
    </requirements>
    <command detect_errors="exit_code">
        <![CDATA[

            mkdir 'output' 'samples' &&
            
            #if $input.is_select == "pair":
                #for $sample in $samples:
                    ln -s '$sample.forward' 'samples/${sample.element_identifier}_forward.${sample.forward.ext}' &&
                    ln -s '$sample.reverse' 'samples/${sample.element_identifier}_reverse.${sample.reverse.ext}' &&
                #end for
            #else:
                #for $sample in $samples:
                    ln -s '$sample' 'samples/$sample.element_identifier.${sample.ext}' &&
                #end for
            #end if

            fastq_groupmerge.py
            'samples'
            'output'
            #if $metadata:
                --metadata '$metadata'
                --group_col '$group_col'
            #end if
            --sep '$sep'
            #if $input.is_select == 'pair':
                --forward_suffix '_forward'
                --reverse_suffix '_reverse'
            #else:
                --single_reads
            #end if

        ]]>
    </command>
    <inputs>
        <conditional name="input"> 
            <param name="is_select" type="select" label="Check which type of input you want to use">
                <option value="single">Single reads</option>
                <option value="pair" selected="true">Paired reads</option>
            </param>
            <when value="single">
                <param name="samples" type="data_collection" collection_type="list" format="fastq,fastq.gz" label="Input single sample(s) read(s) collection"/>
                <param argument="--metadata" type="data" multiple="false" format="tabular,txt" optional="true" label="Input metadata table file" help="If no metadata table is set as input this tool will merge all forward/reverse reads from the sample together into one forward/reverse read!"/>
                <param argument="--sep" type="select" label="Select seperator for metadata file">
                    <option value="," selected="true">,</option>
                    <option value="\t">Tab</option>
                    <option value=" ">Space</option>
                    <option value=";">;</option> 
                    <option value=":">:</option>
                </param>
                <param argument="--group_col" type="text" value="group" label="Input the column name of the `group` column" help="The metadata file should contain two columns, one with the sample names and one where each of the sample should be group to. Look at the help section for more information!"/>
            </when>
            <when value="pair">
                <param name="samples" type="data_collection" collection_type="list:paired" format="fastq,fastq.gz" label="Input paired sample(s) read(s) collection"/>
                <param argument="--metadata" type="data" multiple="false" format="tabular,txt" optional="true" label="Input metadata table file" help="If no metadata table is set as input this tool will merge all forward/reverse reads from the sample together into one forward/reverse read!"/>
                <param argument="--sep" type="select" label="Select seperator for metadata file">
                    <option value="," selected="true">,</option>
                    <option value="\t">Tab</option>
                    <option value=" ">Space</option>
                    <option value=";">;</option> 
                    <option value=":">:</option>
                </param>
                <param argument="--group_col" type="text" value="group" label="Input the column name of the `group` column" help="The metadata file should contain two columns, one with the sample names and one where each of the sample should be group to. Look at the help section for more information!"/>
            </when>
        </conditional>
    </inputs>
    <outputs>
        <collection name="merged_samples_pairs" type="list:paired" label="${tool.name} on ${on_string}: MERGED SAMPLES [PAIRS]">
            <discover_datasets pattern="(?P&lt;identifier_0&gt;[^_]+)_(?P&lt;identifier_1&gt;[^_]+)\.fastq.gz" ext="fastq.gz" directory="output"/>
            <filter>input['is_select'] == 'pair'</filter>
        </collection>
        <collection name="merged_samples_single" type="list" label="${tool.name} on ${on_string}: MERGED SAMPLES [SINGLE]">
            <discover_datasets pattern="(?P&lt;identifier_0&gt;[^_]+)\.fastq.gz" ext="fastq.gz" directory="output"/>
            <filter>input['is_select'] == 'single'</filter>
        </collection>
    </outputs>
    <tests>
        <test expect_num_outputs="1">
            <conditional name="input">
                <param name="is_select" value="pair"/>
                <param name="samples">
                    <collection type="list:paired">
                        <element name="A1">
                            <collection type="paired">
                                <element name="forward" value="A1_forward.fastq.gz" ftype="fastq.gz"/>
                                <element name="reverse" value="A1_reverse.fastq.gz" ftype="fastq.gz"/>
                            </collection>
                        </element>
                        <element name="B1">
                            <collection type="paired">
                                <element name="forward" value="B1_forward.fastq" ftype="fastq"/>
                                <element name="reverse" value="B1_reverse.fastq" ftype="fastq"/>
                            </collection>
                        </element>
                    </collection>
                </param>
                <param name="metadata" value="metadata_1.csv" ftype="tabular"/>
                <param name="group_col" value="TEST_COLUMN"/> 
            </conditional>
            <output_collection name="merged_samples_pairs" type="list:paired" count="2">
                <element name="control">
                    <element name="forward" value="control_forward.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
                    <element name="reverse" value="control_reverse.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
                </element>
                <element name="single">
                    <element name="forward" value="single_forward.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
                    <element name="reverse" value="single_reverse.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
                </element>
            </output_collection>
        </test>
        <test expect_num_outputs="1">
            <conditional name="input">
                <param name="is_select" value="pair"/>
                <param name="samples">
                    <collection type="list:paired">
                        <element name="A2">
                            <collection type="paired">
                                <element name="forward" value="A2_R1.fastq" ftype="fastq"/>
                                <element name="reverse" value="A2_R2.fastq" ftype="fastq"/>
                            </collection>
                        </element>
                        <element name="B2">
                            <collection type="paired">
                                <element name="forward" value="B2_R1.fastq" ftype="fastq"/>
                                <element name="reverse" value="B2_R2.fastq" ftype="fastq"/>
                            </collection>
                        </element>
                    </collection>
                </param>
                <param name="metadata" value="metadata_2.csv" ftype="tabular"/>
            </conditional>
            <output_collection name="merged_samples_pairs" type="list:paired" count="1">
                <element name="treatment">
                    <element name="forward" value="treatment_forward.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
                    <element name="reverse" value="treatment_reverse.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
                </element>
            </output_collection>
        </test>
        <test expect_num_outputs="1">
            <conditional name="input">
                <param name="is_select" value="single"/>
                <param name="samples">
                    <collection type="list">
                        <element name="A1_forward" value="A1_forward.fastq.gz" ftype="fastq.gz"/>
                        <element name="A1_reverse" value="A1_reverse.fastq.gz" ftype="fastq.gz"/>
                        <element name="B1_forward" value="B1_forward.fastq" ftype="fastq"/>
                        <element name="B1_reverse" value="B1_reverse.fastq" ftype="fastq"/>
                    </collection>
                </param>
                <param name="sep" value=":"/>
            </conditional>
            <output_collection name="merged_samples_single" type="list" count="1">
                    <element name="merged" value="Test.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
            </output_collection>
        </test>
        <test expect_num_outputs="1">
            <conditional name="input">
                <param name="is_select" value="pair"/>
                <param name="samples">
                    <collection type="list:paired">
                        <element name="A1">
                            <collection type="paired">
                                <element name="forward" value="A1_forward.fastq.gz" ftype="fastq.gz"/>
                                <element name="reverse" value="A1_reverse.fastq.gz" ftype="fastq.gz"/>
                            </collection>
                        </element>
                        <element name="B1">
                            <collection type="paired">
                                <element name="forward" value="B1_forward.fastq" ftype="fastq"/>
                                <element name="reverse" value="B1_reverse.fastq" ftype="fastq"/>
                            </collection>
                        </element>
                    </collection>
                </param>
            </conditional>
            <output_collection name="merged_samples_pairs" type="list:paired" count="1">
                <element name="merged">
                    <element name="forward" value="merged_forward.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
                    <element name="reverse" value="merged_reverse.fastq.gz" ftype="fastq.gz" compare="sim_size"/>
                </element>
            </output_collection>
        </test>
    </tests>
    <help>
        <![CDATA[

            **What does this tool**

            This tool is designed to group samples reads together based on a given metadata file.
            This way it is more simpler in a workflow to work with multiple samples which also can be group together to open the possibility for example co-assemble.

            **Input**

            - A collection of pair reads which can be in fastq or fastq format
            - OPTIONAL BUT RECOMMENDED: a metadata file

            The metadata file can look look like this for example:

            .. metadata table::

                sample_id,group
                A1,control
                B1,control
                A1,A1
                Test,
                ,Test
            
            Important to this:

            - The column sample_id always has to be in there and there the names of the files WITHOUT the suffix is written.
            - The column 'group' can ne called anything and there the name of the group has to written. All lines where the group is the same will be end of merged together in the output file. In the example file the output 'control_forward.fastq.gz' will contain the forward reads from 'A1' and 'B1'
            - When there is a empty entry in any column this line will be ignored!
            - When using the single read option note that in the 'sample_id' column the file name has to be stated completely therefore as example for input 'test_read.fastq' a line in the metadata table has to be 'test_read' 
            - If metadata file is given only the sample reads stated in this file will be taken into account so you can also add the collection where other sample reads in this collection, they will be ignored if there are not stated in the metadata file!

            **Output**

            - For each group stated in the 'group' column a forward file [{group_name}_{forward_suffix}.fastq.gz] and a reverse file [{group_name}_{reverse_suffix}.fastq.gz] will be created
            - When no metadata is given all inputs which match to the 'forward_suffix' and 'reverse_suffix' will be merged together into one file each for forward and reverse!

        ]]>
    </help>
    <citations>
        <citation type="bibtex">@misc{BibEntry2025Oct,
            title = {{fastq-groupmerge}},
            author = {Santino Faack (SantaMcCloud)},
            journal = {GitHub},
            year = {2025},
            month = oct,
            url = {https://github.com/SantaMcCloud/fastq-groupmerge}
        }</citation>
    </citations> 
</tool>